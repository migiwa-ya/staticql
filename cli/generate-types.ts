#!/usr/bin/env tsx

import { zodToTs, createTypeAlias, printNode } from "zod-to-ts";
import path from "path";
import fs from "fs/promises";
import { pathToFileURL } from "url";

// Recursively unwrap ZodEffects, ZodDefault, etc. to get to the base schema
function unwrapSchema(schema: any): any {
  while (schema && schema._def) {
    const typeName = schema._def.typeName;
    if (
      typeName === "ZodEffects" ||
      typeName === "ZodDefault" ||
      typeName === "ZodOptional" ||
      typeName === "ZodNullable"
    ) {
      schema = schema._def.schema || schema._def.innerType;
    } else if (typeName === "ZodArray") {
      schema = schema._def.type;
      break;
    } else {
      break;
    }
  }
  return schema;
}

async function run() {
  const [inputConfig, inputOut] = process.argv.slice(2);
  const configPath = path.resolve(
    process.cwd(),
    inputConfig || "staticql.config.ts"
  );
  const outputDir = path.resolve(process.cwd(), inputOut || "types");
  const outPath = path.resolve(outputDir || "types/", "staticql-types.d.ts");

  let db;

  try {
    const configModule = await import(pathToFileURL(configPath).href);
    db = configModule.default;

    if (!db || typeof db.index !== "function") {
      throw new Error(
        "staticql.config.ts が正しく defineContentDB() を export していません。"
      );
    }
  } catch (err) {
    console.error("Config 読み込みに失敗しました");
    console.error(err);
    process.exit(1);
  }

  const sources: Record<string, any> = db.config?.sources || db.sources;

  let typeDefs = `// Auto-generated by cli/generate-types.ts\n\n`;

  // First pass: generate all record, index, and relation types
  const recordTypeStrings: string[] = [];
  const indexTypeStrings: string[] = [];
  const relationTypeStrings: string[] = [];
  const recordFieldMaps: Record<string, Record<string, string>> = {};

  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    // Record type
    let schema = sourceDef.schema;
    if (!schema) continue;
    schema = unwrapSchema(schema);
    const identifier =
      sourceName[0].toUpperCase() + sourceName.slice(1) + "Record";

    let { node } = zodToTs(schema, identifier);
    const typeAlias = createTypeAlias(node, identifier);
    let nodeString = printNode(typeAlias);

    // If there are relations, append them to the type string
    if (sourceDef.relations) {
      const firstBrace = nodeString.indexOf("{");
      const lastBrace = nodeString.lastIndexOf("}");
      if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        let body = nodeString.slice(firstBrace + 1, lastBrace).trim();
        for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
          let relType: string = "hasOne";
          if (
            relDef &&
            typeof relDef === "object" &&
            "type" in relDef &&
            typeof (relDef as any).type === "string"
          ) {
            relType = (relDef as any).type;
          }
          const targetSource =
            relDef && typeof relDef === "object" && "to" in relDef
              ? (relDef as any).to
              : "unknown";
          const targetType =
            targetSource[0].toUpperCase() + targetSource.slice(1) + "Record";
          let valueType = targetType;
          if (relType === "hasMany" || relType === "hasManyThrough") {
            valueType = `${targetType}[]`;
          }
          body += `\n  ${relKey}?: ${valueType};`;
        }
        nodeString =
          nodeString.slice(0, firstBrace + 1) +
          "\n" +
          body +
          "\n" +
          nodeString.slice(lastBrace);
      }
    }
    recordTypeStrings.push(`export ${nodeString}\n`);

    // Parse the record type fields and their types for meta type resolution
    const recordFields: Record<string, string> = {};
    const firstBrace = nodeString.indexOf("{");
    const lastBrace = nodeString.lastIndexOf("}");
    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
      const body = nodeString.slice(firstBrace + 1, lastBrace).trim();
      const fieldRegex = /^\s*([\w$]+)\??:\s*([^;]+);/gm;
      let match;
      while ((match = fieldRegex.exec(body)) !== null) {
        recordFields[match[1]] = match[2].trim();
      }
    }
    recordFieldMaps[identifier] = recordFields;

    // Index types
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        indexTypeStrings.push(
          `export type ${
            sourceName[0].toUpperCase() + sourceName.slice(1)
          }Index_${field.replace(/\W/g, "_")} = Record<string, string[]>;\n`
        );
      }
    }

    // Relation record types
    if (sourceDef.relations) {
      for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
        let relType: string = "hasOne";
        if (
          relDef &&
          typeof relDef === "object" &&
          "type" in relDef &&
          typeof (relDef as any).type === "string"
        ) {
          relType = (relDef as any).type;
        }
        let valueType = "string";
        if (relType === "hasMany" || relType === "hasManyThrough") {
          valueType = "string[]";
        }
        relationTypeStrings.push(
          `export type ${
            sourceName[0].toUpperCase() + sourceName.slice(1)
          }Relation_${relKey} = Record<string, ${valueType}>;\n`
        );
      }
    }
  }

  // Helper to check primitive types
  function isPrimitiveType(typeStr: string) {
    return (
      typeStr === "string" ||
      typeStr === "number" ||
      typeStr === "boolean" ||
      typeStr === "null" ||
      typeStr === "undefined" ||
      typeStr === "any"
    );
  }

  // Second pass: generate all meta types, now that all record types are available
  const metaTypeStrings: string[] = [];
  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    if (!sourceDef.meta) continue;
    const identifier =
      sourceName[0].toUpperCase() + sourceName.slice(1) + "Record";
    const recordFields = recordFieldMaps[identifier];

    let metaType = `export type ${
      sourceName[0].toUpperCase() + sourceName.slice(1)
    }Meta = Record<string, {\n`;

    for (const metaField of sourceDef.meta) {
      let fieldType = "any";
      const parts = metaField.split(".");
      let currentType = recordFields[parts[0]];

      if (currentType) {
        if (parts.length === 1) {
          fieldType = currentType;
        } else {
          // Recursively resolve nested type for arbitrary depth
          let typeStr = currentType;
          let isArray = false;
          let i = 1;
          while (i < parts.length && typeStr) {
            if (typeStr.endsWith("[]")) {
              isArray = true;
              typeStr = typeStr.slice(0, -2);
            }
            if (isPrimitiveType(typeStr)) {
              typeStr = "any";
              break;
            }
            // Look up the referenced type in recordFieldMaps
            const refFields = recordFieldMaps[typeStr];
            if (refFields) {
              typeStr = refFields[parts[i]];
              i++;
            } else {
              typeStr = "any";
              break;
            }
          }
          fieldType = isArray && typeStr ? `${typeStr}[]` : typeStr || "any";
        }
      }

      // If nested (relational), always allow undefined
      if (parts.length > 1) {
        metaType += `  "${metaField}"?: ${fieldType};\n`;
      } else {
        metaType += `  "${metaField}": ${fieldType};\n`;
      }
    }
    metaType += `}>;\n\n`;
    metaTypeStrings.push(metaType);
  }

  // Output all type definitions in the correct order
  typeDefs += recordTypeStrings.join("") + "\n";
  typeDefs += indexTypeStrings.join("") + "\n";
  typeDefs += metaTypeStrings.join("") + "\n";
  typeDefs += relationTypeStrings.join("") + "\n";

  await fs.writeFile(outPath, typeDefs, "utf-8");
  console.log(`Types generated to ${outPath}`);
}

run();
