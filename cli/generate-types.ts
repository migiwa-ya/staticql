#!/usr/bin/env tsx

import { zodToTs, createTypeAlias, printNode } from "zod-to-ts";
import path from "path";
import fs from "fs/promises";
import { pathToFileURL } from "url";

// Recursively unwrap ZodEffects, ZodDefault, etc. to get to the base schema
function unwrapSchema(schema: any): any {
  while (schema && schema._def) {
    const typeName = schema._def.typeName;
    if (
      typeName === "ZodEffects" ||
      typeName === "ZodDefault" ||
      typeName === "ZodOptional" ||
      typeName === "ZodNullable"
    ) {
      schema = schema._def.schema || schema._def.innerType;
    } else if (typeName === "ZodArray") {
      schema = schema._def.type;
      break;
    } else {
      break;
    }
  }
  return schema;
}

async function run() {
  const [inputConfig, inputOut] = process.argv.slice(2);
  const configPath = path.resolve(
    process.cwd(),
    inputConfig || "staticql.config.ts"
  );
  const outputDir = path.resolve(process.cwd(), inputOut || "types");
  const outPath = path.resolve(outputDir || "types/", "staticql-types.d.ts");

  let db;

  try {
    const configModule = await import(pathToFileURL(configPath).href);
    db = configModule.default;

    if (!db || typeof db.index !== "function") {
      throw new Error(
        "staticql.config.ts が正しく defineContentDB() を export していません。"
      );
    }
  } catch (err) {
    console.error("Config 読み込みに失敗しました");
    console.error(err);
    process.exit(1);
  }

  const sources: Record<string, any> = db.config?.sources || db.sources;

  let typeDefs = `// Auto-generated by scripts/generate-types.ts\n\n`;

  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    // Record type
    let schema = sourceDef.schema;
    if (!schema) continue;
    // Recursively unwrap to get the base schema for a record
    schema = unwrapSchema(schema);
    const identifier =
      sourceName[0].toUpperCase() + sourceName.slice(1) + "Record";

    // Generate base type as string
    let { node } = zodToTs(schema, identifier);
    const typeAlias = createTypeAlias(node, identifier);
    let nodeString = printNode(typeAlias);

    // If there are relations, append them to the type string
    if (sourceDef.relations) {
      const firstBrace = nodeString.indexOf("{");
      const lastBrace = nodeString.lastIndexOf("}");
      if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        let body = nodeString.slice(firstBrace + 1, lastBrace).trim();
        // Append each relation field
        for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
          let relType: string = "hasOne";
          if (
            relDef &&
            typeof relDef === "object" &&
            "type" in relDef &&
            typeof (relDef as any).type === "string"
          ) {
            relType = (relDef as any).type;
          }
          const targetSource =
            relDef && typeof relDef === "object" && "to" in relDef
              ? (relDef as any).to
              : "unknown";
          const targetType =
            targetSource[0].toUpperCase() + targetSource.slice(1) + "Record";
          let valueType = targetType;
          if (relType === "hasMany" || relType === "hasManyThrough") {
            valueType = `${targetType}[]`;
          }
          body += `\n  ${relKey}?: ${valueType};`;
        }
        nodeString =
          nodeString.slice(0, firstBrace + 1) +
          "\n" +
          body +
          "\n" +
          nodeString.slice(lastBrace);
      }
    }
    typeDefs += `export ${nodeString}` + "\n\n";

    // Index types
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        typeDefs += `export type ${
          sourceName[0].toUpperCase() + sourceName.slice(1)
        }Index_${field.replace(/\W/g, "_")} = Record<string, string[]>;\n`;
      }
      typeDefs += "\n";
    }

    // Meta type
    if (sourceDef.meta) {
      typeDefs += `export type ${
        sourceName[0].toUpperCase() + sourceName.slice(1)
      }Meta = Record<string, {\n`;
      for (const metaField of sourceDef.meta) {
        typeDefs += `  "${metaField}": any;\n`;
      }
      typeDefs += `}>;\n\n`;
    }

    // Relation record types
    if (sourceDef.relations) {
      for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
        // Determine relation type safely
        let relType: string = "hasOne";
        if (
          relDef &&
          typeof relDef === "object" &&
          "type" in relDef &&
          typeof (relDef as any).type === "string"
        ) {
          relType = (relDef as any).type;
        }

        let valueType = "string";
        if (relType === "hasMany" || relType === "hasManyThrough") {
          valueType = "string[]";
        }

        typeDefs += `export type ${
          sourceName[0].toUpperCase() + sourceName.slice(1)
        }Relation_${relKey} = Record<string, ${valueType}>;\n`;
      }
      typeDefs += "\n";
    }
  }

  await fs.writeFile(outPath, typeDefs, "utf-8");
  console.log(`Types generated to ${outPath}`);
}

run();
