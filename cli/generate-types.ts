#!/usr/bin/env tsx

import { zodToTs, createTypeAlias, printNode } from "zod-to-ts";
import path from "path";
import fs from "fs/promises";
import { pathToFileURL } from "url";

// Recursively unwrap ZodEffects, ZodDefault, etc. to get to the base schema
function unwrapSchema(schema: any): any {
  while (schema && schema._def) {
    const typeName = schema._def.typeName;
    if (
      typeName === "ZodEffects" ||
      typeName === "ZodDefault" ||
      typeName === "ZodOptional" ||
      typeName === "ZodNullable"
    ) {
      schema = schema._def.schema || schema._def.innerType;
    } else if (typeName === "ZodArray") {
      schema = schema._def.type;
      break;
    } else {
      break;
    }
  }
  return schema;
}

async function run() {
  const [inputConfig, inputOut] = process.argv.slice(2);
  const configPath = path.resolve(
    process.cwd(),
    inputConfig || "staticql.config.ts"
  );
  const outputDir = path.resolve(process.cwd(), inputOut || "types");
  const outPath = path.resolve(outputDir || "types/", "staticql-types.d.ts");

  let db;

  try {
    const configModule = await import(pathToFileURL(configPath).href);
    db = configModule.default;

    if (!db || typeof db.index !== "function") {
      throw new Error(
        "staticql.config.ts が正しく defineContentDB() を export していません。"
      );
    }
  } catch (err) {
    console.error("Config 読み込みに失敗しました");
    console.error(err);
    process.exit(1);
  }

  const sources: Record<string, any> = db.config?.sources || db.sources;

  let typeDefs = `// Auto-generated by scripts/generate-types.ts\n\n`;

  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    // Record type
    let schema = sourceDef.schema;
    if (!schema) continue;
    // Recursively unwrap to get the base schema for a record
    schema = unwrapSchema(schema);
    const identifier =
      sourceName[0].toUpperCase() + sourceName.slice(1) + "Record";

    const { node } = zodToTs(schema, identifier);
    const typeAlias = createTypeAlias(node, identifier);
    const nodeString = printNode(typeAlias);
    typeDefs += `export ${nodeString}` + "\n\n";

    // Index types
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        typeDefs += `export type ${
          sourceName[0].toUpperCase() + sourceName.slice(1)
        }Index_${field.replace(/\W/g, "_")} = Record<string, string[]>;\n`;
      }
      typeDefs += "\n";
    }

    // Meta type
    if (sourceDef.meta) {
      typeDefs += `export type ${
        sourceName[0].toUpperCase() + sourceName.slice(1)
      }Meta = Record<string, {\n`;
      for (const metaField of sourceDef.meta) {
        typeDefs += `  "${metaField}": any;\n`;
      }
      typeDefs += `}>;\n\n`;
    }
  }

  await fs.writeFile(outPath, typeDefs, "utf-8");
  console.log(`Types generated to ${outPath}`);
}

run();
