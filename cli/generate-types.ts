#!/usr/bin/env node

import path from "path";
import { promises as fs } from "fs";
import { SourceConfig } from "../src/SourceConfigResolver";
import { ConsoleLogger } from "../src/logger/ConsoleLogger.js";

const logger = new ConsoleLogger("info");

/**
 * Main CLI entry point.
 */
async function run() {
  const { config, outPath } = await getArgs();
  const typeDefs = generateTypeDefs(config);
  await writeTypeDefs(outPath, typeDefs);
}

run();

/**
 * Parses CLI arguments and loads the config file.
 */
async function getArgs() {
  let [configPath, outputDir] = process.argv.slice(2);

  if (!configPath || !outputDir) {
    logger.warn(
      "Error: Expected at least 2 arguments: <config_file> <output_dir>"
    );
    process.exit(1);
  }

  const outPath = path.join(outputDir, "staticql-types.d.ts");
  configPath = path.resolve(process.cwd(), configPath);

  let config: any;
  try {
    const configRaw = await fs.readFile(configPath, "utf-8");
    config = JSON.parse(configRaw);
  } catch (err) {
    logger.warn("Failed to read or parse config file.");
    logger.warn(err);
    process.exit(1);
  }

  return { config, outPath };
}

/**
 * Writes the generated TypeScript type definitions to a file.
 */
async function writeTypeDefs(outPath: string, typeDefs: string) {
  try {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
    await fs.writeFile(outPath, typeDefs);
    logger.info(`Types generated to ${outPath}`);
  } catch (err) {
    logger.warn("Failed to write type definition file.");
    logger.warn(err);
    process.exit(1);
  }
}

/**
 * Generates TypeScript type definitions from StaticQL config schema.
 */
function generateTypeDefs(config: any): string {
  const sources = config.sources || {};
  let typeDefs = `// Auto-generated by generate-types.ts\n\n`;
  typeDefs += `type SourceRecord = {};\n\n`;
  typeDefs += `type CustomIndex = { __brand: "CustomIndex" };\n\n`;

  const sourceTypeMapEntries: string[] = [];

  for (const [sourceName, sourceDefAny] of Object.entries(sources) as [
    string,
    any
  ][]) {
    const sourceDef = sourceDefAny as SourceConfig;
    const schema = sourceDef.schema;
    const typeName = `${capitalize(sourceName)}Record`;

    sourceTypeMapEntries.push(`  ${sourceName}: ${typeName};`);

    if (schema.properties && !schema.properties?.slug) {
      schema.required?.push("slug");
      schema.properties.slug = { type: "string" };
    }

    let finalTypeString = jsonSchemaToTypeString(schema);

    // define customIndex fields
    const customIndexFields = new Set<string>();
    if (Array.isArray(sourceDef.customIndex)) {
      for (const entry of sourceDef.customIndex) {
        if (typeof entry === "string") {
          customIndexFields.add(entry);
        } else if (typeof entry === "object" && entry !== null) {
          for (const key of Object.keys(entry)) {
            customIndexFields.add(key);
          }
        }
      }
    }
    const schemaProps = schema.properties ? Object.keys(schema.properties) : [];
    const customFieldStr = Array.from(customIndexFields)
      .filter((name) => !schemaProps.includes(name))
      .map((name) => `${name}: CustomIndex`)
      .join("; ");

    if (customFieldStr) {
      finalTypeString = finalTypeString.replace(/^\{/, `{ ${customFieldStr};`);
    }

    if (sourceDef.relations) {
      const relationFields = Object.entries(sourceDef.relations)
        .map(([key, rel]: [string, any]) => {
          const targetType = `${capitalize(rel.to || "unknown")}Record`;
          const relType = rel.type;
          let valueType = targetType;
          if (
            ["hasMany", "hasManyThrough", "belongsToMany"].includes(relType)
          ) {
            valueType += "[]";
          } else if (relType === "belongsTo") {
            valueType += " | null";
          }
          return `${key}?: ${valueType}`;
        })
        .join("; ");
      finalTypeString = finalTypeString.replace(/^\{/, `{ ${relationFields};`);
    }

    typeDefs += `export type ${typeName} = SourceRecord & ${finalTypeString};\n\n`;

    const explicitIndexFields = new Set<string>();
    const index = [
      ...(sourceDef.index ?? []),
      ...(sourceDef.customIndex ?? []),
    ];
    if (index) {
      for (const field of index) {
        if (typeof field === "string") {
          explicitIndexFields.add(field);
          const safeField = field.replace(/\W/g, "_");
          typeDefs += `export type ${capitalize(
            sourceName
          )}Index_${safeField} = Record<string, string[]>;\n\n`;
        } else if (typeof field === "object" && field !== null) {
          for (const [key, value] of Object.entries(field)) {
            explicitIndexFields.add(key);
            const safeField = key.replace(/\W/g, "_");
            typeDefs += `export type ${capitalize(
              sourceName
            )}Index_${safeField} = Record<string, string[]>;\n\n`;
          }
        }
      }
    }

    for (const [otherSourceName, otherSourceDefAny] of Object.entries(
      sources
    ) as [string, any][]) {
      if (otherSourceName === sourceName) continue;
      const otherSourceDef = otherSourceDefAny as SourceConfig;
      if (!otherSourceDef.relations) continue;

      for (const [relKey, relDefAny] of Object.entries(
        otherSourceDef.relations
      )) {
        const relDef = relDefAny as any;
        if (relDef.to !== sourceName) continue;

        let field: string | null = null;
        if (
          ["belongsTo", "belongsToMany", "hasOne", "hasMany"].includes(
            relDef.type
          )
        ) {
          field = relDef.foreignKey === "slug" ? null : relDef.foreignKey;
        } else if (
          relDef.type === "hasOneThrough" ||
          relDef.type === "hasManyThrough"
        ) {
          field =
            relDef.targetForeignKey === "slug"
              ? null
              : `${relDef.targetForeignKey}.slug`;
        }

        if (!field || explicitIndexFields.has(field)) continue;
        explicitIndexFields.add(field);
        const safeField = field.replace(/\W/g, "_");
        typeDefs += `export type ${capitalize(
          sourceName
        )}Index_${safeField} = Record<string, string[]>;\n\n`;
      }
    }

    if (sourceDef.relations) {
      for (const [key, relDefAny] of Object.entries(sourceDef.relations)) {
        const relDef = relDefAny as any;
        const valueType = [
          "hasMany",
          "hasManyThrough",
          "belongsToMany",
        ].includes(relDef.type)
          ? "string[]"
          : relDef.type === "belongsTo"
          ? "string | null"
          : "string";
        typeDefs += `export type ${capitalize(
          sourceName
        )}Relation_${key} = Record<string, ${valueType}>;\n\n`;
      }
    }
  }

  if (sourceTypeMapEntries.length > 0) {
    typeDefs += `export type SourceTypeMap = {\n${sourceTypeMapEntries.join(
      "\n"
    )}\n};\n\n`;
  }

  return typeDefs;
}

/**
 * Converts a simplified JSON Schema to a TypeScript type string.
 */
function jsonSchemaToTypeString(schema: any): string {
  if (!schema || typeof schema !== "object") return "any";

  switch (schema.type) {
    case "string":
      return "string";
    case "number":
    case "integer":
      return "number";
    case "boolean":
      return "boolean";
    case "array":
      return `${jsonSchemaToTypeString(schema.items)}[]`;
    case "object":
      if (schema.properties) {
        const required = Array.isArray(schema.required) ? schema.required : [];
        const fields = Object.entries(schema.properties)
          .map(([key, value]: [string, any]) => {
            const isRequired = required.includes(key);
            return `${key}${isRequired ? "" : "?"}: ${jsonSchemaToTypeString(
              value
            )}`;
          })
          .join("; ");
        return `{ ${fields} }`;
      }
      return "{ [key: string]: any }";
    default:
      return "any";
  }
}

/**
 * Capitalizes the first letter of a string.
 */
function capitalize(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
