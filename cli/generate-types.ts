#!/usr/bin/env node

import path from "path";
import { promises as fs } from "fs";
import { SourceConfig } from "../src/SourceConfigResolver";
import { ConsoleLogger } from "../src/logger/ConsoleLogger.js";

const logger = new ConsoleLogger("info");

async function run() {
  const { config, outPath } = await getArgs();
  const typeDefs = generateTypeDefs(config);
  await writeTypeDefs(outPath, typeDefs);
}

run();

async function getArgs() {
  let [configPath, outputDir] = process.argv.slice(2);

  if (!configPath || !outputDir) {
    logger.warn(
      "Error: Expected at least 2 arguments: <config_file> <output_dir>"
    );
    process.exit(1);
  }

  const outPath = path.join(outputDir, "staticql-types.d.ts");
  configPath = path.resolve(process.cwd(), configPath);

  let config: any;
  try {
    const configRaw = await fs.readFile(configPath, "utf-8");
    config = JSON.parse(configRaw);
  } catch (err) {
    logger.warn("Config 読み込みに失敗しました");
    logger.warn(err);
    process.exit(1);
  }

  return { config, outPath };
}

async function writeTypeDefs(outPath: string, typeDefs: string) {
  try {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
    await fs.writeFile(outPath, typeDefs);
    logger.info(`Types generated to ${outPath}`);
  } catch (err) {
    logger.warn("型定義ファイルの出力に失敗しました");
    logger.warn(err);
    process.exit(1);
  }
}

function generateTypeDefs(config: any): string {
  const sources = config.sources || {};

  let typeDefs = `// Auto-generated by generate-types.ts\n\n`;

  // 推論のための共通型（src/SourceConfigResolver.ts）
  typeDefs += `type SourceRecord = {};\n\n`;

  // sourceName -> typeName のマッピングを保持
  const sourceTypeMapEntries: string[] = [];

  for (const [sourceName, sourceDefAny] of Object.entries(sources) as [
    string,
    any
  ][]) {
    const sourceDef = sourceDefAny as SourceConfig;
    const schema = sourceDef.schema;
    const typeName = `${capitalize(sourceName)}Record`;

    // マッピング用エントリを追加
    sourceTypeMapEntries.push(`  ${sourceName}: ${typeName};`);

    // slug は自動設定
    if (schema.properties && !schema.properties?.slug) {
      schema.required?.push("slug");
      schema.properties.slug = { type: "string" };
    }

    const baseTypeString = jsonSchemaToTypeString(schema);

    let finalTypeString = baseTypeString;

    // relations を型に追加
    if (sourceDef.relations) {
      const relationFields = Object.entries(
        sourceDef.relations as Record<string, any>
      )
        .map(([key, relDefAny]) => {
          const relDef = relDefAny as any;
          const targetSource = relDef?.to || "unknown";
          const targetType = `${capitalize(targetSource)}Record`;
          const relationType = relDef?.type || "hasOne";
          let valueType = targetType;
          if (
            ["hasMany", "hasManyThrough", "belongsToMany"].includes(
              relationType
            )
          ) {
            valueType += "[]";
          } else if (relationType === "belongsTo") {
            valueType += " | null";
          }
          return `${key}?: ${valueType}`;
        })
        .join("; ");

      finalTypeString = baseTypeString.replace(/^\{/, `{ ${relationFields};`);
    }

    typeDefs += `export type ${typeName} = SourceRecord & ${finalTypeString};\n\n`;

    // index 型（明示的指定）
    const explicitIndexFields = new Set<string>();
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        explicitIndexFields.add(field);
        const safeField = field.replace(/\W/g, "_");
        typeDefs += `export type ${capitalize(
          sourceName
        )}Index_${safeField} = Record<string, string[]>;\n\n`;
      }
    }

    // index 型（リレーション参照による追加）
    for (const [otherSourceName, otherSourceDefAny] of Object.entries(
      sources
    ) as [string, any][]) {
      if (otherSourceName === sourceName) continue;
      const otherSourceDef = otherSourceDefAny as any;
      if (!otherSourceDef.relations) continue;
      for (const [relKey, relDefAny] of Object.entries(
        otherSourceDef.relations as Record<string, any>
      )) {
        const relDef = relDefAny as any;
        if (relDef.to !== sourceName) continue;
        let field: string | null = null;
        if (
          relDef.type === "belongsTo" ||
          relDef.type === "belongsToMany" ||
          relDef.type === "hasOne" ||
          relDef.type === "hasMany"
        ) {
          field = relDef.foreignKey === "slug" ? null : relDef.foreignKey;
        } else if (
          relDef.type === "hasOneThrough" ||
          relDef.type === "hasManyThrough"
        ) {
          field =
            relDef.targetForeignKey === "slug"
              ? null
              : `${relDef.targetForeignKey}.slug`;
        }
        if (!field) continue;
        if (explicitIndexFields.has(field)) continue; // 重複回避
        explicitIndexFields.add(field);
        const safeField = field.replace(/\W/g, "_");
        typeDefs += `export type ${capitalize(
          sourceName
        )}Index_${safeField} = Record<string, string[]>;\n\n`;
      }
    }

    // relation型
    if (sourceDef.relations) {
      for (const [key, relDefAny] of Object.entries(
        sourceDef.relations as Record<string, any>
      )) {
        const relDef = relDefAny as any;
        const targetType = [
          "hasMany",
          "hasManyThrough",
          "belongsToMany",
        ].includes(relDef.type)
          ? "string[]"
          : relDef.type === "belongsTo"
          ? "string | null"
          : "string";
        typeDefs += `export type ${capitalize(
          sourceName
        )}Relation_${key} = Record<string, ${targetType}>;\n\n`;
      }
    }
  }

  // sourceName -> typeName マッピング型を出力
  if (sourceTypeMapEntries.length > 0) {
    typeDefs += `export type SourceTypeMap = {\n${sourceTypeMapEntries.join(
      "\n"
    )}\n};\n\n`;
  }

  return typeDefs;
}

/**
 * JSON Schema から TypeScript 型文字列を生成（再帰）
 */
function jsonSchemaToTypeString(schema: any): string {
  if (!schema || typeof schema !== "object") return "any";
  switch (schema.type) {
    case "string":
      return "string";
    case "number":
    case "integer":
      return "number";
    case "boolean":
      return "boolean";
    case "array":
      if (schema.items) {
        return `${jsonSchemaToTypeString(schema.items)}[]`;
      }
      return "any[]";
    case "object":
      if (schema.properties) {
        const required = Array.isArray(schema.required) ? schema.required : [];
        const fields = Object.entries(schema.properties)
          .map(([key, value]: [string, any]) => {
            const isRequired = required.includes(key);
            return `${key}${isRequired ? "" : "?"}: ${jsonSchemaToTypeString(
              value
            )}`;
          })
          .join("; ");
        return `{ ${fields} }`;
      }
      return "{ [key: string]: any }";
    default:
      return "any";
  }
}

/**
 * 1文字目を大文字化
 */
function capitalize(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
