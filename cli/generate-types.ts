#!/usr/bin/env node

import { zodToTs, createTypeAlias, printNode } from "zod-to-ts";
import path from "path";
import { pathToFileURL } from "url";
import { FileSystemProvider } from "../src/storage/FileSystemProvider.js";

// Recursively unwrap ZodEffects, ZodDefault, etc. to get to the base schema
function unwrapSchema(schema: any): any {
  while (schema && schema._def) {
    const typeName = schema._def.typeName;
    if (
      typeName === "ZodEffects" ||
      typeName === "ZodDefault" ||
      typeName === "ZodOptional" ||
      typeName === "ZodNullable"
    ) {
      schema = schema._def.schema || schema._def.innerType;
    } else if (typeName === "ZodArray") {
      schema = schema._def.type;
      break;
    } else {
      break;
    }
  }
  return schema;
}

// Type guard for Zod schema
function isZodSchema(obj: any): obj is { _def: any } {
  return obj && typeof obj === "object" && "_def" in obj;
}

// Extract record type fields and their types for meta type resolution using Zod schema introspection
function extractZodFields(schema: any): Record<string, any> {
  // Do not unwrap at the start! Only unwrap as needed.
  if (isZodSchema(schema) && schema._def?.typeName === "ZodObject") {
    const shape = schema._def.shape();
    const fields: Record<string, any> = {};
    for (const [key, value] of Object.entries(shape)) {
      // Check for ZodArray before unwrapping further
      if (isZodSchema(value) && value._def?.typeName === "ZodArray") {
        const arrayType = unwrapSchema(value._def.type);
        if (isZodSchema(arrayType)) {
          if (arrayType._def?.typeName === "ZodObject") {
            fields[key] = { arrayOf: extractZodFields(arrayType) };
          } else {
            let arrType =
              arrayType._def?.typeName === "ZodString"
                ? "string"
                : arrayType._def?.typeName === "ZodNumber"
                ? "number"
                : arrayType._def?.typeName === "ZodBoolean"
                ? "boolean"
                : "any";
            fields[key] = { arrayOf: arrType };
          }
        } else {
          fields[key] = { arrayOf: "any" };
        }
      } else if (isZodSchema(value)) {
        const unwrapped = unwrapSchema(value);
        if (isZodSchema(unwrapped)) {
          const typeName = unwrapped._def?.typeName;
          if (typeName === "ZodObject") {
            fields[key] = extractZodFields(unwrapped);
          } else if (typeName === "ZodString") {
            fields[key] = "string";
          } else if (typeName === "ZodNumber") {
            fields[key] = "number";
          } else if (typeName === "ZodBoolean") {
            fields[key] = "boolean";
          } else if (typeName === "ZodLiteral") {
            fields[key] = JSON.stringify(unwrapped._def.value);
          } else if (typeName === "ZodDate") {
            fields[key] = "string";
          } else {
            fields[key] = "any";
          }
        } else {
          fields[key] = "any";
        }
      } else {
        fields[key] = "any";
      }
    }
    return fields;
  }
  return {};
}

// Helper to check primitive types
function isPrimitiveType(typeStr: string) {
  return (
    typeStr === "string" ||
    typeStr === "number" ||
    typeStr === "boolean" ||
    typeStr === "null" ||
    typeStr === "undefined" ||
    typeStr === "any"
  );
}

// Helper to convert nested object to TypeScript type string
function objectToTypeString(obj: any): string {
  if (obj && typeof obj === "object" && "arrayOf" in obj) {
    return objectToTypeString(obj.arrayOf) + "[]";
  }
  if (Array.isArray(obj)) {
    return objectToTypeString(obj[0]) + "[]";
  }
  if (typeof obj === "object" && obj !== null) {
    return (
      "{ " +
      Object.entries(obj)
        .map(([k, v]) => `${k}: ${objectToTypeString(v)}`)
        .join("; ") +
      " }"
    );
  }
  return String(obj);
}

async function run() {
  const [inputConfig, inputOut] = process.argv.slice(2);
  const configPath = path.resolve(
    process.cwd(),
    inputConfig || "staticql.config.ts"
  );
  const outputDir = inputOut || "types";
  const outPath =
    (outputDir.endsWith("/") ? outputDir : outputDir + "/") +
    "staticql-types.d.ts";

  let db;

  try {
    const configModule = await import(pathToFileURL(configPath).href);
    db = await configModule.default;

    if (!db) {
      throw new Error(
        "staticql.config.ts が正しく defineContentDB() を export していません。"
      );
    }
  } catch (err) {
    console.error("Config 読み込みに失敗しました");
    console.error(err);
    process.exit(1);
  }

  const sources: Record<string, any> = db.config?.sources || db.sources;

  let typeDefs = `// Auto-generated by cli/generate-types.ts\n\n`;

  // First pass: generate all record, index, and relation types
  const recordTypeStrings: string[] = [];
  const indexTypeStrings: string[] = [];
  const relationTypeStrings: string[] = [];
  const recordFieldMaps: Record<string, Record<string, string>> = {};

  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    // Record type
    let schema = sourceDef.schema;
    if (!schema) continue;
    schema = unwrapSchema(schema);
    const identifier =
      sourceName[0].toUpperCase() + sourceName.slice(1) + "Record";

    let { node } = zodToTs(schema, identifier);
    const typeAlias = createTypeAlias(node, identifier);
    let nodeString = printNode(typeAlias);

    // If there are relations, append them to the type string
    if (sourceDef.relations) {
      const firstBrace = nodeString.indexOf("{");
      const lastBrace = nodeString.lastIndexOf("}");
      if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
        let body = nodeString.slice(firstBrace + 1, lastBrace).trim();
        for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
          let relType: string = "hasOne";
          if (
            relDef &&
            typeof relDef === "object" &&
            "type" in relDef &&
            typeof (relDef as any).type === "string"
          ) {
            relType = (relDef as any).type;
          }
          const targetSource =
            relDef && typeof relDef === "object" && "to" in relDef
              ? (relDef as any).to
              : "unknown";
          const targetType =
            targetSource[0].toUpperCase() + targetSource.slice(1) + "Record";
          let valueType = targetType;
          if (
            relType === "hasMany" ||
            relType === "hasManyThrough" ||
            relType === "belongsToMany"
          ) {
            valueType = `${targetType}[]`;
          } else if (relType === "belongsTo") {
            valueType = `${targetType} | null`;
          }
          body += `\n  ${relKey}?: ${valueType};`;
        }
        nodeString =
          nodeString.slice(0, firstBrace + 1) +
          "\n" +
          body +
          "\n" +
          nodeString.slice(lastBrace);
      }
    }
    recordTypeStrings.push(`export ${nodeString}\n`);

    const recordFields = extractZodFields(schema);

    // Add relation fields to recordFields for meta type resolution
    if (sourceDef.relations) {
      for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
        let relType: string = "hasOne";
        if (
          relDef &&
          typeof relDef === "object" &&
          "type" in relDef &&
          typeof (relDef as any).type === "string"
        ) {
          relType = (relDef as any).type;
        }
        const targetSource =
          relDef && typeof relDef === "object" && "to" in relDef
            ? (relDef as any).to
            : "unknown";
        const targetType =
          targetSource[0].toUpperCase() + targetSource.slice(1) + "Record";
        let valueType = targetType;
        if (
          relType === "hasMany" ||
          relType === "hasManyThrough" ||
          relType === "belongsToMany"
        ) {
          valueType = `${targetType}[]`;
        } else if (relType === "belongsTo") {
          valueType = `${targetType} | null`;
        }
        recordFields[relKey] = valueType;
      }
    }

    recordFieldMaps[identifier] = recordFields;

    // Index types
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        indexTypeStrings.push(
          `export type ${
            sourceName[0].toUpperCase() + sourceName.slice(1)
          }Index_${field.replace(/\W/g, "_")} = Record<string, string[]>;\n`
        );
      }
    }

    // Relation record types
    if (sourceDef.relations) {
      for (const [relKey, relDef] of Object.entries(sourceDef.relations)) {
        let relType: string = "hasOne";
        if (
          relDef &&
          typeof relDef === "object" &&
          "type" in relDef &&
          typeof (relDef as any).type === "string"
        ) {
          relType = (relDef as any).type;
        }
        let valueType = "string";
        if (
          relType === "hasMany" ||
          relType === "hasManyThrough" ||
          relType === "belongsToMany"
        ) {
          valueType = "string[]";
        } else if (relType === "belongsTo") {
          valueType = "string | null";
        }
        relationTypeStrings.push(
          `export type ${
            sourceName[0].toUpperCase() + sourceName.slice(1)
          }Relation_${relKey} = Record<string, ${valueType}>;\n`
        );
      }
    }
  }
  // Second pass: generate all meta types, now that all record types are available
  const metaTypeStrings: string[] = [];
  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    if (!sourceDef.meta) continue;
    const identifier =
      sourceName[0].toUpperCase() + sourceName.slice(1) + "Record";
    const recordFields = recordFieldMaps[identifier];

    let metaType = `export type ${
      sourceName[0].toUpperCase() + sourceName.slice(1)
    }Meta = Record<string, {\n`;

    for (const metaField of sourceDef.meta) {
      let fieldType = "any";
      const parts = metaField.split(".");
      let currentType = recordFields[parts[0]];

      if (currentType) {
        if (parts.length === 1) {
          fieldType =
            typeof currentType === "object"
              ? objectToTypeString(currentType)
              : currentType;
        } else {
          // Recursively resolve nested type for arbitrary depth
          let typeStr = currentType;
          let isArray = false;
          let i = 1;
          while (i < parts.length && typeStr) {
            if (typeof typeStr === "string" && typeStr.endsWith("[]")) {
              isArray = true;
              typeStr = typeStr.slice(0, -2);
            }
            if (isPrimitiveType(typeStr)) {
              typeStr = "any";
              break;
            }
            // Look up the referenced type in recordFieldMaps
            const refFields = recordFieldMaps[typeStr];
            if (refFields) {
              typeStr = refFields[parts[i]];
              i++;
            } else if (typeof typeStr === "object" && typeStr !== null) {
              // when oject array
              if (Object.prototype.hasOwnProperty.call(typeStr, "arrayOf")) {
                typeStr = typeStr["arrayOf"][parts[i]] + "[]";
                break;
              } else {
                typeStr = typeStr[parts[i]];
                i++;
              }
            } else {
              typeStr = "any";
              break;
            }
          }
          fieldType = isArray && typeStr ? `${typeStr}[]` : typeStr || "any";
        }
      }

      // If nested (relational), always allow undefined
      if (parts.length > 1) {
        metaType += `  "${metaField}"?: ${fieldType};\n`;
      } else {
        metaType += `  "${metaField}": ${fieldType};\n`;
      }
    }
    metaType += `}>;\n\n`;
    metaTypeStrings.push(metaType);
  }

  // Output all type definitions in the correct order
  typeDefs += recordTypeStrings.join("") + "\n";
  typeDefs += indexTypeStrings.join("") + "\n";
  typeDefs += metaTypeStrings.join("") + "\n";
  typeDefs += relationTypeStrings.join("") + "\n";

  const provider = new FileSystemProvider(db.config?.storage?.baseDir);
  await provider.writeFile(outPath, typeDefs);
  console.log(`Types generated to ${outPath}`);
}

run();
