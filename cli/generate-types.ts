#!/usr/bin/env node

import path from "path";
import { promises as fs } from "fs";

async function run() {
  const [inputConfig, inputOut] = process.argv.slice(2);
  const configPath = path.resolve(
    process.cwd(),
    inputConfig || "tests/staticql.config.json"
  );
  const outputDir = inputOut || "tests/types";
  const outPath = path.join(outputDir, "staticql-types.d.ts");

  let config: any;
  try {
    const configRaw = await fs.readFile(configPath, "utf-8");
    config = JSON.parse(configRaw);
  } catch (err) {
    console.error("Config 読み込みに失敗しました");
    console.error(err);
    process.exit(1);
  }

  const sources = config.sources || {};

  let typeDefs = `// Auto-generated by generate-types.ts\n\n`;

  // sourceName -> typeName のマッピングを保持
  const sourceTypeMapEntries: string[] = [];

  for (const [sourceName, sourceDefAny] of Object.entries(sources) as [
    string,
    any
  ][]) {
    const sourceDef = sourceDefAny as any;
    const schema = sourceDef.schema;
    const typeName = `${capitalize(sourceName)}Record`;

    // マッピング用エントリを追加
    sourceTypeMapEntries.push(`  ${sourceName}: ${typeName};`);

    const baseTypeString = jsonSchemaToTypeString(schema);

    let finalTypeString = baseTypeString;

    // relations を型に追加
    if (sourceDef.relations) {
      const relationFields = Object.entries(
        sourceDef.relations as Record<string, any>
      )
        .map(([key, relDefAny]) => {
          const relDef = relDefAny as any;
          const targetSource = relDef?.to || "unknown";
          const targetType = `${capitalize(targetSource)}Record`;
          const relationType = relDef?.type || "hasOne";
          let valueType = targetType;
          if (
            ["hasMany", "hasManyThrough", "belongsToMany"].includes(
              relationType
            )
          ) {
            valueType += "[]";
          } else if (relationType === "belongsTo") {
            valueType += " | null";
          }
          return `${key}?: ${valueType}`;
        })
        .join("; ");

      finalTypeString = baseTypeString.replace(/^\{/, `{ ${relationFields};`);
    }

    typeDefs += `export type ${typeName} = ${finalTypeString};\n\n`;

    // index 型（明示的指定）
    const explicitIndexFields = new Set<string>();
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        explicitIndexFields.add(field);
        const safeField = field.replace(/\W/g, "_");
        typeDefs += `export type ${capitalize(
          sourceName
        )}Index_${safeField} = Record<string, string[]>;\n\n`;
      }
    }

    // index 型（リレーション参照による追加）
    for (const [otherSourceName, otherSourceDefAny] of Object.entries(
      sources
    ) as [string, any][]) {
      if (otherSourceName === sourceName) continue;
      const otherSourceDef = otherSourceDefAny as any;
      if (!otherSourceDef.relations) continue;
      for (const [relKey, relDefAny] of Object.entries(
        otherSourceDef.relations as Record<string, any>
      )) {
        const relDef = relDefAny as any;
        if (relDef.to !== sourceName) continue;
        let field: string | null = null;
        if (
          relDef.type === "belongsTo" ||
          relDef.type === "belongsToMany" ||
          relDef.type === "hasOne" ||
          relDef.type === "hasMany"
        ) {
          field = relDef.foreignKey === "slug" ? null : relDef.foreignKey;
        } else if (
          relDef.type === "hasOneThrough" ||
          relDef.type === "hasManyThrough"
        ) {
          field =
            relDef.targetForeignKey === "slug"
              ? null
              : `${relDef.targetForeignKey}.slug`;
        }
        if (!field) continue;
        if (explicitIndexFields.has(field)) continue; // 重複回避
        explicitIndexFields.add(field);
        const safeField = field.replace(/\W/g, "_");
        typeDefs += `export type ${capitalize(
          sourceName
        )}Index_${safeField} = Record<string, string[]>;\n\n`;
      }
    }

    // relation型
    if (sourceDef.relations) {
      for (const [key, relDefAny] of Object.entries(
        sourceDef.relations as Record<string, any>
      )) {
        const relDef = relDefAny as any;
        const targetType = [
          "hasMany",
          "hasManyThrough",
          "belongsToMany",
        ].includes(relDef.type)
          ? "string[]"
          : relDef.type === "belongsTo"
          ? "string | null"
          : "string";
        typeDefs += `export type ${capitalize(
          sourceName
        )}Relation_${key} = Record<string, ${targetType}>;\n\n`;
      }
    }
  }

  // sourceName -> typeName マッピング型を出力
  if (sourceTypeMapEntries.length > 0) {
    typeDefs += `export type SourceTypeMap = {\n${sourceTypeMapEntries.join(
      "\n"
    )}\n};\n\n`;
  }

  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, typeDefs);

  console.log(`Types generated to ${outPath}`);
}

run();

/**
 * JSON Schema から TypeScript 型文字列を生成（再帰）
 */
function jsonSchemaToTypeString(schema: any): string {
  if (!schema || typeof schema !== "object") return "any";
  switch (schema.type) {
    case "string":
      return "string";
    case "number":
    case "integer":
      return "number";
    case "boolean":
      return "boolean";
    case "array":
      if (schema.items) {
        return `${jsonSchemaToTypeString(schema.items)}[]`;
      }
      return "any[]";
    case "object":
      if (schema.properties) {
        const required = Array.isArray(schema.required) ? schema.required : [];
        const fields = Object.entries(schema.properties)
          .map(([key, value]: [string, any]) => {
            const isRequired = required.includes(key);
            return `${key}${isRequired ? "" : "?"}: ${jsonSchemaToTypeString(
              value
            )}`;
          })
          .join("; ");
        return `{ ${fields} }`;
      }
      return "{ [key: string]: any }";
    default:
      return "any";
  }
}

/**
 * 1文字目を大文字化
 */
function capitalize(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
