#!/usr/bin/env node

import path from "path";
import { pathToFileURL } from "url";
import { promises as fs } from "fs";
import { StaticQL } from "../src/StaticQL.js";

/**
 * 型展開用：必要に応じて unwrap する
 */
function unwrapSchema(schema: any): any {
  while (schema && schema._def) {
    const typeName = schema._def.typeName;
    if (
      ["ZodEffects", "ZodDefault", "ZodOptional", "ZodNullable"].includes(
        typeName
      )
    ) {
      schema = schema._def.schema || schema._def.innerType;
    } else if (typeName === "ZodArray") {
      schema = schema._def.type;
      break;
    } else {
      break;
    }
  }
  return schema;
}

/**
 * ZodスキーマからTS型文字列を作る（再帰）
 */
function zodSchemaToTypeString(schema: any): string {
  const unwrapped = unwrapSchema(schema);
  if (!unwrapped || !unwrapped._def) return "any";

  const typeName = unwrapped._def.typeName;

  switch (typeName) {
    case "ZodString":
      return "string";
    case "ZodNumber":
      return "number";
    case "ZodBoolean":
      return "boolean";
    case "ZodDate":
      return "string";
    case "ZodLiteral":
      return JSON.stringify(unwrapped._def.value);
    case "ZodArray":
      return `${zodSchemaToTypeString(unwrapped._def.type)}[]`;
    case "ZodObject":
      const shape = unwrapped._def.shape();
      const fields = Object.entries(shape)
        .map(([key, value]) => `${key}: ${zodSchemaToTypeString(value)}`)
        .join("; ");
      return `{ ${fields} }`;
    default:
      return "any";
  }
}

/**
 * 1文字目を大文字化
 */
function capitalize(str: string) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * メイン処理
 */
async function run() {
  const [inputConfig, inputOut] = process.argv.slice(2);
  const configPath = path.resolve(
    process.cwd(),
    inputConfig || "staticql.config.ts"
  );
  const outputDir = inputOut || "types";
  const outPath = path.join(outputDir, "staticql-types.d.ts");

  let staticql: StaticQL;

  try {
    const configModule = await import(pathToFileURL(configPath).href);
    staticql = await configModule.default();

    if (!staticql) {
      throw new Error(
        "staticql.config.ts が正しく defineStaticQL() を export していません。"
      );
    }
  } catch (err) {
    console.error("Config 読み込みに失敗しました");
    console.error(err);
    process.exit(1);
  }

  const sources: StaticQL["config"]["sources"] = staticql.getConfig()?.sources;

  let typeDefs = `// Auto-generated by generate-types.ts\n\n`;

  for (const [sourceName, sourceDef] of Object.entries(sources)) {
    const schema = unwrapSchema(sourceDef.schema);
    const typeName = `${capitalize(sourceName)}Record`;

    const baseTypeString = zodSchemaToTypeString(schema);

    let finalTypeString = baseTypeString;

    // relations を型に追加
    if (sourceDef.relations) {
      const relationFields = Object.entries(sourceDef.relations)
        .map(([key, relDef]: any) => {
          const targetSource = relDef?.to || "unknown";
          const targetType = `${capitalize(targetSource)}Record`;
          const relationType = relDef?.type || "hasOne";
          let valueType = targetType;
          if (
            ["hasMany", "hasManyThrough", "belongsToMany"].includes(
              relationType
            )
          ) {
            valueType += "[]";
          } else if (relationType === "belongsTo") {
            valueType += " | null";
          }
          return `${key}?: ${valueType}`;
        })
        .join("; ");

      finalTypeString = baseTypeString.replace(/^\{/, `{ ${relationFields};`);
    }

    typeDefs += `export type ${typeName} = ${finalTypeString};\n\n`;

    // index 型
    if (sourceDef.index) {
      for (const field of sourceDef.index) {
        const safeField = field.replace(/\W/g, "_");
        typeDefs += `export type ${capitalize(
          sourceName
        )}Index_${safeField} = Record<string, string[]>;\n\n`;
      }
    }

    // relation型
    if (sourceDef.relations) {
      for (const [key, relDef] of Object.entries(sourceDef.relations)) {
        const targetType = [
          "hasMany",
          "hasManyThrough",
          "belongsToMany",
        ].includes(relDef.type)
          ? "string[]"
          : relDef.type === "belongsTo"
          ? "string | null"
          : "string";
        typeDefs += `export type ${capitalize(
          sourceName
        )}Relation_${key} = Record<string, ${targetType}>;\n\n`;
      }
    }

    // meta型
    if (sourceDef.meta) {
      typeDefs += `export type ${capitalize(
        sourceName
      )}Meta = Record<string, {\n`;
      for (const metaField of sourceDef.meta) {
        typeDefs += `  "${metaField}": any;\n`;
      }
      typeDefs += `}>;\n\n`;
    }
  }

  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, typeDefs);

  console.log(`Types generated to ${outPath}`);
}

run();
